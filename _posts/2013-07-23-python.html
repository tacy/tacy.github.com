---
layout: post
title: "python notes"
description: "python学习点滴"
categories: [tech]
tags: [python, program]
---


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 语法</a></li>
<li><a href="#sec-2">2 String</a>
<ul>
<li><a href="#sec-2-1">2.1 encoding</a></li>
</ul>
</li>
<li><a href="#sec-3">3 Regex</a>
<ul>
<li><a href="#sec-3-1">3.1 MyDemo</a></li>
<li><a href="#sec-3-2">3.2 findall group  - return tuple</a></li>
<li><a href="#sec-3-3">3.3 Options</a></li>
<li><a href="#sec-3-4">3.4 Substitution</a></li>
</ul>
</li>
<li><a href="#sec-4">4 Python分支</a>
<ul>
<li><a href="#sec-4-1">4.1 Stackless Python</a></li>
<li><a href="#sec-4-2">4.2 PyPy</a></li>
</ul>
</li>
<li><a href="#sec-5">5 Django &amp; Flask</a></li>
<li><a href="#sec-6">6 Twisted &amp; Tornado &amp; gevent &amp; eventlet</a></li>
<li><a href="#sec-7">7 一些必读的文章</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">语法</h2>
<div class="outline-text-2" id="text-1">

<ul>
<li>type(objectName)    查看对象类型
</li>
<li>string,tuple is immutable
</li>
<li>变量不用定义，所以你在给变量取名字的时候最好带上变量类型，比如aItem,这样你能很清楚知道你的变量类型
</li>
</ul>


</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">String</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">encoding<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup></h3>
<div class="outline-text-3" id="text-2-1">

<p>   python内部都用unicode做中介，比如你要把一个string转换成utf-8，必须先做unicode()，然后才能去做encode()转换：
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;str.encode('utf-8')
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe6 in position 0: ordinal not in range(128)
</pre>

<p>
   上面例子中，str在做encode的时候，会先去做unicode()，转换成unicode编码，然后再从unicode编码格式encode()成utf-8，问题就处在内部的unicode()这个步骤上，python缺省做unicode()用的编码是ASCII，而‘斯坦福’是不能用ASCII表达的，这就出现了上面的错误。要解决上面的问题，必须你告诉python用什么编码做unicode():
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;str = unicode(str, 'utf-8')
&gt;str.encode('utf-8')
'\xe6\x96\xaf\xe5\x9d\xa6\xe7\xa6\x8f'
&gt;str.encode('gb18030')
'\xcb\xb9\xcc\xb9\xb8\xa3'
</pre>

<p>
   上面我们显示指定了unicode()的编码，这样str就能正确unicode()。
</p>
<p>
   另外注意我们上面指定的unicode()编码，这个也不能随便写，python编码规范要求你指定源代码编码<sup><a class="footref" name="fnr-.2" href="#fn-.2">2</a></sup>，例如你指定coding为”# -*- coding: utf-8 -*-“，那么你在对str做unicode()的时候就不能用gbk去做，会出错：
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;unicode(str, 'gb18030')
UnicodeDecodeError: 'gb18030' codec can't decode byte 0x8f in position 8: incomplete multibyte sequence
</pre>


<p>
   转换一个str成为url也比较麻烦，你要先对他做正确的encode，然后还要quote:
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;str = unicode(str, 'utf-8')
&gt;urllib2.quote(str.encode('utf-8')
'%E6%96%AF%E5%9D%A6%E7%A6%8F'
</pre>

<p>
   当然，你还得根据不同网站的编码做不同转换，如果网站用的编码是gbk，你这里就需要encode成gbk
</p>
<p>
   另外看下面一些例子，关于转换结果之间的关系：
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;ustr = u'斯坦福'
&gt;str
'\xe6\x96\xaf\xe5\x9d\xa6\xe7\xa6\x8f'
&gt;ustr
u'\u65af\u5766\u798f'
&gt;ustr2 = unicode(str, 'utf-8')
&gt;ustr2 == ustr
True
&gt;str2 = ustr2.encode('utf-8')
&gt;str == str2
True
&gt;ustr2 == str2.decode('utf-8')
True
</pre>


</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Regex<sup><a class="footref" name="fnr-.3" href="#fn-.3">3</a></sup></h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1">MyDemo</h3>
<div class="outline-text-3" id="text-3-1">




<pre class="example">str = 'atestaa,btestbb,'
rs = re.match(r'test.*', str)   不匹配，match是从第一个字符开始匹配
rs = re.match(r'.test.*', str)  匹配，rs.group()输出 'atestaa,btestbb,'
rs = re.match(r'.test.*,', str) 匹配，注意patten后面多了一个逗号字符，但是匹配结果同上，因为缺省是贪吃模式，原则是最长匹配
rs = re.match(r'.test.*?,', str) 匹配，注意patten中多了一个问好，匹配结果变成了 'atestaa,',改变模式为最短匹配
rs = re.match(r'.test(.*?),', str) 匹配，group模式，patten中多了一对括号，匹配结果同上，只是括号中表达式匹配的字符会单独存放在re.group(1)中，本例中为'aa'
rs = re.match(r'.test(.*?),.test(.*?),', str) 匹配，多了一个re.group(2)，本例中存放'bb'
rs = re.search   使用方式同match，唯一区别就是search从任意位置开始匹配，而match必须从第一个字符开始匹配，另外match和search都是一次匹配
rs = re.findall(r'test(.*?),', str)   匹配，多次匹配模式，rs输出['aa', 'bb']，return list
</pre>


<p>
   复杂的例子：
</p>


<pre class="example">re = re.search(r'(x|y)(x|y)', 'xy')   这里匹配xx，xy，yx，yy，但是如果你只想匹配xy和yx的时候怎么办呢
rs = re.search(r'(?:(x)|y)(?(1)y|x)', 'xy')     #匹配xy或者yx，不匹配xx，yy，解释一下，第一个大括号里面是表示当找到x的时候，存入group（1）里面，如果是y则不存入group（1），后面一个括号里面表示如果group（1）存在，则继续匹配y，否则匹配x
</pre>


</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2">findall group  - return tuple</h3>
<div class="outline-text-3" id="text-3-2">




<pre class="example">str = 'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'
tuples = re.findall(r'([\w\.-]+)@([\w\.-]+)', str)
print tuples  ## [('alice', 'google.com'), ('bob', 'abc.com')]
for tuple in tuples:
  print tuple[0]  ## username
  print tuple[1]  ## host
</pre>


</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3">Options</h3>
<div class="outline-text-3" id="text-3-3">

<p>   The re functions take options to modify the behavior of the pattern match. The option flag is added as an extra argument to the search() or findall() etc., e.g. re.search(pat, str, re.IGNORECASE).
</p>
<ul>
<li>IGNORECASE &ndash; ignore upper/lowercase differences for matching, so 'a' matches both 'a' and 'A'.
</li>
<li>DOTALL &ndash; allow dot (.) to match newline &ndash; normally it matches anything but newline. This can trip you up &ndash; you think .* matches everything, but by default it does not go past the end of a line. Note that \s (whitespace) includes newlines, so if you want to match a run of whitespace that may include a newline, you can just use \s*
</li>
<li>MULTILINE &ndash; Within a string made of many lines, allow ^ and $ to match the start and end of each line. Normally ^/$ would just match the start and end of the whole string.
</li>
</ul>


</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4">Substitution</h3>
<div class="outline-text-3" id="text-3-4">

<p>   The re.sub(pat, replacement, str) function searches for all the instances of pattern in the given string, and replaces them. The replacement string can include '\1', '\2' which refer to the text from group(1), group(2), and so on from the original matching text.
</p>
<p>
   Here's an example which searches for all the email addresses, and changes them to keep the user (\1) but have yo-yo-dyne.com as the host.
</p>


<pre class="example">str = 'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'
## re.sub(pat, replacement, str) -- returns new string with all replacements,
## \1 is group(1), \2 group(2) in the replacement
print re.sub(r'([\w\.-]+)@([\w\.-]+)', r'\1@yo-yo-dyne.com', str)
## purple alice@yo-yo-dyne.com, blah monkey bob@yo-yo-dyne.com blah dishwasher
</pre>


</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Python分支</h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1">Stackless Python<sup><a class="footref" name="fnr-.4" href="#fn-.4">4</a></sup></h3>
<div class="outline-text-3" id="text-4-1">

<p>   先看看wikipedia上的解释：
   "Stackless microthreads are managed by the language interpreter itself, not the operating system kernel—context switching and task scheduling is done purely in the interpreter (these are thus also regarded as a form of green thread). This avoids many of the overheads of threads, because no mode switching between user mode and kernel mode needs to be done, and can significantly reduce CPU load in some high-concurrency situations.Due to the considerable number of changes in the source, Stackless Python cannot be installed on a preexisting Python installation as an extension or library. It is instead a complete Python distribution in itself. The majority of Stackless's features have also been implemented in PyPy, a self-hosting Python interpreter and JIT compiler."
   stackless是一个python的分支实现，主要的优势就是microthread，其实就是协程（coroutines / green threads），轻量级别的伪线程，采用栈方式实现协程切换，不会带来ContextSwitch，缺点是需要自己管理协程调用栈，stackless能实现10，0000级别的连接.
</p>


<pre class="example">from greenlet import greenlet
def test1():
    print 12
    gr2.switch()
    print 34

def test2():
    print 56
    gr1.switch()
    print 78   #not to be printed

gr1 = greenlet(test1)
gr2 = greenlet(test2)
gr1.switch()
</pre>


</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2">PyPy</h3>
<div class="outline-text-3" id="text-4-2">

<p>   实现了一个JIT，运行时转换python代码到机器码，主要关注在运行效率的提升，和原生python兼容，采用RPython（python的一个子集）实现，目前好像还没有看到那里有大规模的使用。关于PyPy和CPython的性能讨论可以看这里<sup><a class="footref" name="fnr-.5" href="#fn-.5">5</a></sup>
</p>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Django &amp; Flask</h2>
<div class="outline-text-2" id="text-5">

<p>  Django是一个整体解决方案，Python Web framework，实现快速开发网站，你不用做什么其他技术选择，比如templage engine、ORM等，社区很活跃。
  Flask是一个microframework，基于Werkzeug和Jinja2，Flash核心非常简单，不像Django帮你做了所有技术决策，缺省template engine用的是jinja。
</p></div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">Twisted &amp; Tornado &amp; gevent &amp; eventlet</h2>
<div class="outline-text-2" id="text-6">

<p>  Twisted是一个经典的非阻塞I/O框架，采用Callback方式实现异步调用，用户最广
  gevent和eventlet都是基于协程的异步框架（底下是greenlet），gevent是eventlet之后的一个项目，作者当时的一些需求不能被eventlet满足而重新设计的<sup><a class="footref" name="fnr-.6" href="#fn-.6">6</a></sup>，gevent地下的I/O异步框架是libevent/livev（epoll on linux / kqueue on FreeBSD / iocp on windows)，evenlet自己实现的。
</p>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">一些必读的文章</h2>
<div class="outline-text-2" id="text-7">

<ul>
<li><a href="http://docs.python-guide.org/en/latest/">The Hitchhiker’s Guide to Python!</a>
</li>
<li><a href="http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained">The Python yield keyword explained</a>
</li>
<li><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python">How can I make a chain of function decorators in Python?</a>
</li>
<li><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">What is a metaclass in Python?</a>
</li>
<li><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python">Hidden features of Python</a>
</li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style Guide</a>
</li>
<li><a href="http://stackoverflow.com/questions/2709821/python-self-explained">Python 'self' explained</a>
</li>
<li><a href="http://docs.python.org/release/2.5/whatsnew/pep-343.html">PEP 343: The 'with' statement</a>
</li>
</ul>


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> Unicode HOWTO: <a href="http://docs.python.org/2/howto/unicode.html">http://docs.python.org/2/howto/unicode.html</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.2" href="#fnr-.2">2</a></sup> PEP 0263: <a href="http://www.python.org/dev/peps/pep-0263/">http://www.python.org/dev/peps/pep-0263/</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.3" href="#fnr-.3">3</a></sup> Google Python Regex: <a href="https://developers.google.com/edu/python/regular-expressions">https://developers.google.com/edu/python/regular-expressions</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.4" href="#fnr-.4">4</a></sup> Stackless: <a href="http://en.wikipedia.org/wiki/Stackless_Python">http://en.wikipedia.org/wiki/Stackless_Python</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.5" href="#fnr-.5">5</a></sup> Pypy - How can it possibly beat CPython: <a href="http://stackoverflow.com/questions/2591879/pypy-how-can-it-possibly-beat-cpython">http://stackoverflow.com/questions/2591879/pypy-how-can-it-possibly-beat-cpython</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.6" href="#fnr-.6">6</a></sup> Comparing gevent to eventlet: <a href="http://blog.gevent.org/2010/02/27/why-gevent/">http://blog.gevent.org/2010/02/27/why-gevent/</a>
</p>


</div>
</div>

</div>
</div>
