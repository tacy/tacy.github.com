---
layout: post
title: "python notes"
description: "python学习点滴"
categories: [tech]
tags: [python, program]
---

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Core type</a></li>
<li><a href="#sec-2">2 String</a>
<ul>
<li><a href="#sec-2-1">2.1 encoding</a></li>
</ul>
</li>
<li><a href="#sec-3">3 Regex</a>
<ul>
<li><a href="#sec-3-1">3.1 MyDemo</a></li>
<li><a href="#sec-3-2">3.2 findall group  - return tuple</a></li>
<li><a href="#sec-3-3">3.3 Options</a></li>
<li><a href="#sec-3-4">3.4 Substitution</a></li>
</ul>
</li>
<li><a href="#sec-4">4 function &amp; method</a></li>
<li><a href="#sec-5">5 staticmethod &amp; classmethod &amp; instancemethod</a></li>
<li><a href="#sec-6">6 desctiptor protocol</a></li>
<li><a href="#sec-7">7 scopes &amp; closure</a></li>
<li><a href="#sec-8">8 Python分支</a>
<ul>
<li><a href="#sec-8-1">8.1 Stackless Python</a></li>
<li><a href="#sec-8-2">8.2 PyPy</a></li>
</ul>
</li>
<li><a href="#sec-9">9 Django &amp; Flask</a></li>
<li><a href="#sec-10">10 Twisted &amp; Tornado &amp; gevent &amp; eventlet</a></li>
<li><a href="#sec-11">11 Emacs &amp; Python</a>
<ul>
<li><a href="#sec-11-1">11.1 ipdb</a></li>
</ul>
</li>
<li><a href="#sec-12">12 一些必读的文章</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Core type</h2>
<div class="outline-text-2" id="text-1">

<ul>
<li>integer, string, tuple is immutable, can't by change in-place
</li>
<li>keep in mind that the mutable type is share reference, if you need to change
    them
</li>
<li>You can copy sequence type by slice, but it only copy top-level, if you want
    to completely copy the object, use deepcopy



<pre class="src src-python">&gt;&gt;&gt;<span style="color: #268bd2;">x</span> = [1, 2, [3, 4]]
&gt;&gt;&gt;<span style="color: #268bd2;">y</span> = [<span style="color: #2aa198;">'aa'</span>, x[:]]
&gt;&gt;&gt;<span style="color: #268bd2;">x</span>[0] = 11
&gt;&gt;&gt;x[2][0] = 33
&gt;&gt;&gt;x
[11, 2, [33, 4]]
&gt;&gt;&gt;y
[<span style="color: #2aa198;">'aa'</span>, [1, 2, [33, 4]]
</pre>

</li>
<li>comprehensions
<pre class="example">
[x*2 for x in range(10)]
</pre>

</li>
<li>sorted
    sorted dict by value



<pre class="src src-python"><span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">method 1</span>
<span style="color: #859900;">sorted</span>(d.iteritems(), key=<span style="color: #859900;">lambda</span> x: x[1])   <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">d.items() return list</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">method 2</span>
<span style="color: #859900;">import</span> operator
<span style="color: #268bd2;">x</span> = {1: 2, 3: 4, 4:3, 2:1, 0:0}
<span style="color: #268bd2;">sorted_x</span> = <span style="color: #859900;">sorted</span>(x.iteritems(), key=operator.itemgetter(1))
</pre>

</li>
<li>pickle &amp; struct
    object serialization &amp; C structs represented as Python strings
</li>
</ul>



</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">String</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">encoding<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup></h3>
<div class="outline-text-3" id="text-2-1">

<p>   python内部都用unicode做中介，比如你要把一个string转换成utf-8，必须先做
   unicode()，然后才能去做encode()转换：
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;str.encode('utf-8')
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe6 in position 0:
ordinal not in range(128)
</pre>

<p>
   上面例子中，str在做encode的时候，会先去做unicode()，转换成unicode编码，然后再
   从unicode编码格式encode()成utf-8，问题就处在内部的unicode()这个步骤上，python
   缺省做unicode()用的编码是ASCII，而‘斯坦福’是不能用ASCII表达的，这就出现了
   上面的错误。要解决上面的问题，必须你告诉python用什么编码做unicode():
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;str = unicode(str, 'utf-8')
&gt;str.encode('utf-8')
'\xe6\x96\xaf\xe5\x9d\xa6\xe7\xa6\x8f'
&gt;str.encode('gb18030')
'\xcb\xb9\xcc\xb9\xb8\xa3'
</pre>

<p>
   上面我们显示指定了unicode()的编码，这样str就能正确unicode()。
</p>
<p>
   另外注意我们上面指定的unicode()编码，这个也不能随便写，python编码规范要求你指
   定源代码编码<sup><a class="footref" name="fnr-.2" href="#fn-.2">2</a></sup>，例如你指定coding为”# -*- coding: utf-8 -*-“，那么你在
   对str做unicode()的时候就不能用gbk去做，会出错：
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;unicode(str, 'gb18030')
UnicodeDecodeError: 'gb18030' codec can't decode byte 0x8f in position 8:
incomplete multibyte sequence
</pre>


<p>
   转换一个str成为url也比较麻烦，你要先对他做正确的encode，然后还要quote:
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;str = unicode(str, 'utf-8')
&gt;urllib2.quote(str.encode('utf-8')
'%E6%96%AF%E5%9D%A6%E7%A6%8F'
</pre>

<p>
   当然，你还得根据不同网站的编码做不同转换，如果网站用的编码是gbk，你这里就需要
   encode成gbk
</p>
<p>
   另外看下面一些例子，关于转换结果之间的关系：
</p>


<pre class="example">&gt;str = '斯坦福'
&gt;ustr = u'斯坦福'
&gt;str
'\xe6\x96\xaf\xe5\x9d\xa6\xe7\xa6\x8f'
&gt;ustr
u'\u65af\u5766\u798f'
&gt;ustr2 = unicode(str, 'utf-8')
&gt;ustr2 == ustr
True
&gt;str2 = ustr2.encode('utf-8')
&gt;str == str2
True
&gt;ustr2 == str2.decode('utf-8')
True
</pre>



</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Regex<sup><a class="footref" name="fnr-.3" href="#fn-.3">3</a></sup></h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1">MyDemo</h3>
<div class="outline-text-3" id="text-3-1">




<pre class="src src-python"><span style="color: #859900;">str</span> = <span style="color: #2aa198;">'atestaa,btestbb,'</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#19981;&#21305;&#37197;&#65292;match&#26159;&#20174;&#31532;&#19968;&#20010;&#23383;&#31526;&#24320;&#22987;&#21305;&#37197;</span>
<span style="color: #268bd2;">rs</span> = re.match(r<span style="color: #2aa198;">'test.*'</span>, <span style="color: #859900;">str</span>)
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21305;&#37197;&#65292;rs.group()&#36755;&#20986; 'atestaa,btestbb,'</span>
<span style="color: #268bd2;">rs</span> = re.match(r<span style="color: #2aa198;">'.test.*'</span>, <span style="color: #859900;">str</span>)
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21305;&#37197;&#65292;&#27880;&#24847;patten&#21518;&#38754;&#22810;&#20102;&#19968;&#20010;&#36887;&#21495;&#23383;&#31526;&#65292;&#20294;&#26159;&#21305;&#37197;&#32467;&#26524;&#21516;&#19978;&#65292;&#22240;&#32570;&#30465;&#26159;&#36138;&#21507;&#27169;&#24335;,</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21407;&#21017;&#26159;&#26368;&#38271;&#21305;&#37197;</span>
<span style="color: #268bd2;">rs</span> = re.match(r<span style="color: #2aa198;">'.test.*,'</span>, <span style="color: #859900;">str</span>)
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21305;&#37197;&#65292;&#27880;&#24847;patten&#20013;&#22810;&#20102;&#20010;&#38382;&#21495;&#65292;&#21305;&#37197;&#32467;&#26524;&#21464;&#25104;&#20102;'atestaa,',&#25913;&#21464;&#27169;&#24335;&#20026;&#26368;&#30701;&#21305;&#37197;</span>
<span style="color: #268bd2;">rs</span> = re.match(r<span style="color: #2aa198;">'.test.*?,'</span>, <span style="color: #859900;">str</span>)
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21305;&#37197;&#65292;group&#27169;&#24335;&#65292;patten&#20013;&#22810;&#20102;&#19968;&#23545;&#25324;&#21495;&#65292;&#21305;&#37197;&#32467;&#26524;&#21516;&#19978;&#65292;&#21482;&#26159;&#25324;&#21495;&#20013;&#34920;&#36798;&#24335;&#21305;</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#37197;&#30340;&#23383;&#31526;&#20250;&#21333;&#29420;&#23384;&#25918;&#22312;re.group(1)&#20013;&#65292;&#26412;&#20363;&#20013;&#20026;'aa'</span>
<span style="color: #268bd2;">rs</span> = re.match(r<span style="color: #2aa198;">'.test(.*?),'</span>, <span style="color: #859900;">str</span>)
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21305;&#37197;&#65292;&#22810;&#20102;&#19968;&#20010;re.group(2)&#65292;&#26412;&#20363;&#20013;&#23384;&#25918;'bb'</span>
<span style="color: #268bd2;">rs</span> = re.match(r<span style="color: #2aa198;">'.test(.*?),.test(.*?),'</span>, <span style="color: #859900;">str</span>)
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#20351;&#29992;&#26041;&#24335;&#21516;match&#65292;&#21807;&#19968;&#21306;&#21035;&#23601;&#26159;search&#20174;&#20219;&#24847;&#20301;&#32622;&#24320;&#22987;&#21305;&#37197;&#65292;&#32780;match&#24517;&#39035;&#20174;&#31532;&#19968;&#20010;</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#23383;&#31526;&#24320;&#22987;&#21305;&#37197;&#65292;&#21478;&#22806;match&#21644;search&#37117;&#26159;&#19968;&#27425;&#21305;&#37197;</span>
<span style="color: #268bd2;">rs</span> = re.search
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21305;&#37197;&#65292;&#22810;&#27425;&#21305;&#37197;&#27169;&#24335;&#65292;rs&#36755;&#20986;['aa', 'bb']&#65292;return list</span>
<span style="color: #268bd2;">rs</span> = re.findall(r<span style="color: #2aa198;">'test(.*?),'</span>, <span style="color: #859900;">str</span>)
</pre>


<p>
   复杂的例子：
</p>


<pre class="src src-python"><span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#36825;&#37324;&#21305;&#37197;xx&#65292;xy&#65292;yx&#65292;yy&#65292;&#20294;&#26159;&#22914;&#26524;&#20320;&#21482;&#24819;&#21305;&#37197;xy&#21644;yx&#30340;&#26102;&#20505;&#24590;&#20040;&#21150;&#21602;</span>
<span style="color: #268bd2;">re</span> = re.search(r<span style="color: #2aa198;">'(x|y)(x|y)'</span>, <span style="color: #2aa198;">'xy'</span>)
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21305;&#37197;xy&#25110;&#32773;yx&#65292;&#19981;&#21305;&#37197;xx&#65292;yy&#65292;&#35299;&#37322;&#19968;&#19979;&#65292;&#31532;&#19968;&#20010;&#22823;&#25324;&#21495;&#37324;&#38754;&#26159;&#34920;&#31034;&#24403;&#25214;&#21040;x&#30340;&#26102;</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#20505;&#65292;&#23384;&#20837;group&#65288;1&#65289;&#37324;&#38754;&#65292;&#22914;&#26524;&#26159;y&#21017;&#19981;&#23384;&#20837;group&#65288;1&#65289;&#65292;&#21518;&#38754;&#19968;&#20010;&#25324;&#21495;&#37324;&#38754;&#34920;&#31034;&#22914;</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#26524;group&#65288;1&#65289;&#23384;&#22312;&#65292;&#21017;&#32487;&#32493;&#21305;&#37197;y&#65292;&#21542;&#21017;&#21305;&#37197;x</span>
<span style="color: #268bd2;">rs</span> = re.search(r<span style="color: #2aa198;">'(?:(x)|y)(?(1)y|x)'</span>, <span style="color: #2aa198;">'xy'</span>)
</pre>


</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2">findall group  - return tuple</h3>
<div class="outline-text-3" id="text-3-2">




<pre class="src src-python"><span style="color: #859900;">str</span> = <span style="color: #2aa198;">'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'</span>
<span style="color: #268bd2;">tuples</span> = re.findall(r<span style="color: #2aa198;">'([\w\.-]+)@([\w\.-]+)'</span>, <span style="color: #859900;">str</span>)
<span style="color: #859900;">print</span> tuples  <span style="color: #586e75; font-style: italic;">## </span><span style="color: #586e75; font-style: italic;">[('alice', 'google.com'), ('bob', 'abc.com')]</span>
<span style="color: #859900;">for</span> <span style="color: #859900;">tuple</span> <span style="color: #859900;">in</span> tuples:
  <span style="color: #859900;">print</span> <span style="color: #859900;">tuple</span>[0]  <span style="color: #586e75; font-style: italic;">## </span><span style="color: #586e75; font-style: italic;">username</span>
  <span style="color: #859900;">print</span> <span style="color: #859900;">tuple</span>[1]  <span style="color: #586e75; font-style: italic;">## </span><span style="color: #586e75; font-style: italic;">host</span>
</pre>


</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3">Options</h3>
<div class="outline-text-3" id="text-3-3">

<p>   The re functions take options to modify the behavior of the pattern match.
   The option flag is added as an extra argument to the search() or findall()
   etc., e.g. re.search(pat, str, re.IGNORECASE).
</p>
<ul>
<li>IGNORECASE &ndash; ignore upper/lowercase differences for matching, so 'a'
     matches both 'a' and 'A'.
</li>
<li>DOTALL &ndash; allow dot (.) to match newline &ndash; normally it matches anything
     but newline. This can trip you up &ndash; you think .* matches everything, but
     by default it does not go past the end of a line. Note that \s (whitespace)
     includes newlines, so if you want to match a run of whitespace that may
     include a newline, you can just use \s*
</li>
<li>MULTILINE &ndash; Within a string made of many lines, allow ^ and $ to match the
     start and end of each line. Normally ^/$ would just match the start and end
     of the whole string.
</li>
</ul>


</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4">Substitution</h3>
<div class="outline-text-3" id="text-3-4">

<p>   The re.sub(pat, replacement, str) function searches for all the instances of
   pattern in the given string, and replaces them. The replacement string can
   include '\1', '\2' which refer to the text from group(1), group(2), and so on
   from the original matching text.
</p>
<p>
   Here's an example which searches for all the email addresses, and changes
   them to keep the user (\1) but have yo-yo-dyne.com as the host.
</p>


<pre class="src src-python"><span style="color: #859900;">str</span> = <span style="color: #2aa198;">'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'</span>
<span style="color: #586e75; font-style: italic;">## </span><span style="color: #586e75; font-style: italic;">re.sub(pat, replacement, str) -returns new string with all replacements,</span>
<span style="color: #586e75; font-style: italic;">## </span><span style="color: #586e75; font-style: italic;">\1 is group(1), \2 group(2) in the replacement</span>
<span style="color: #859900;">print</span> re.sub(r<span style="color: #2aa198;">'([\w\.-]+)@([\w\.-]+)'</span>, r<span style="color: #2aa198;">'\1@yo-yo-dyne.com'</span>, <span style="color: #859900;">str</span>)
<span style="color: #586e75; font-style: italic;">## </span><span style="color: #586e75; font-style: italic;">purple alice@yo-yo-dyne.com, blah monkey bob@yo-yo-dyne.com blah</span>
<span style="color: #586e75; font-style: italic;">##</span><span style="color: #586e75; font-style: italic;">dishwasher</span>
</pre>



</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">function &amp; method</h2>
<div class="outline-text-2" id="text-4">

<p>简单来说，function可以通过def和lambda定义，当function定义在class内部时，它通过
descriptor protocol转换成method（这么说也不准确，理论上你依然可以通过__dict__方
式绕开descriptor protocol访问到function）。
</p>
<p>
同时method又分为unbound method和bound method，当我们直接通过class访问method时，
它是unbound method；当我们通过该class的instance访问method时，他是bound method。
</p>


<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">foo</span>(x):
    <span style="color: #859900;">print</span> <span style="color: #2aa198;">'call foo'</span>, x

<span style="color: #859900;">class</span> <span style="color: #b58900;">MyClass</span>(<span style="color: #859900;">object</span>):
    <span style="color: #859900;">def</span> <span style="color: #268bd2;">m1</span>(x):
        <span style="color: #859900;">print</span> <span style="color: #2aa198;">'call m1'</span>, x

    <span style="color: #859900;">def</span> <span style="color: #268bd2;">m2</span>(<span style="color: #859900;">self</span>, y):
        <span style="color: #859900;">print</span> <span style="color: #2aa198;">'call m2'</span>, y

In [259]: foo
Out[259]: &lt;function __main__.foo&gt;

In [260]: MyClass.m1
Out[260]: &lt;unbound method MyClass.m1&gt;

In [261]: <span style="color: #268bd2;">m</span> = MyClass()

In [264]: m.m1
Out[264]: &lt;bound method MyClass.m1 of &lt;__main__.MyClass <span style="color: #859900;">object</span> at 0x1e49c10&gt;&gt;
</pre>

<p>
疑问自然产生，为啥m1是method，明明也是一个function，怎么就变成method了呢，为啥
同样是method还有unbound和bound之分呢，他们之间到底是如何转换的。
</p>
<p>
其实背后的魔法都来自于descriptor protocol，在解释descriptor之前，我们先来看看
方法m1到底是啥?
</p>


<pre class="src src-python">In [281]: foo
Out[281]: &lt;function __main__.foo&gt;

In [282]: MyClass.__dict__.get(<span style="color: #2aa198;">'m1'</span>)
Out[284]: &lt;function __main__.m1&gt;

In [285]: MyClass.m1
Out[285]: &lt;unbound method MyClass.m1&gt;
</pre>

<p>
参考上面的输出，你可以发现m1依然是一个function，你可以通__dict__访问到它，那为
啥通过MyClass.m1访问时，返回的又是method呢？
</p>
<p>
其实问题就在于方法m1是descriptor，要理解这个得费点功夫，建议参考Peter Inglesby
的Discovering Descriptors<sup><a class="footref" name="fnr-.4" href="#fn-.4">4</a></sup>。我这里简单解释一下，首先你需要知道的是，Python
中一切都是对象，m1是一个对象，foo是一个对象，MyClass和m都是对象，而m1是一个实现
了descriptor protocol的对象(实现了__get__,__set__,__del__三个方法中的任意一个）
，当访问descriptor对象时，直接调用__get__方法返回了一个method。
</p>


<pre class="src src-python">In [328]: <span style="color: #2aa198;">'#'</span>.join(<span style="color: #859900;">dir</span>(MyClass.m1))
Out[330]: <span style="color: #2aa198;">'__call__#__class__#__cmp__#__delattr__#__doc__#__format__#__func__#</span>
<span style="color: #2aa198;">__get__#__getattribute__#__hash__#__init__#__new__#__reduce__#__reduce_ex__#</span>
<span style="color: #2aa198;">__repr__#__self__#__setattr__#__sizeof__#__str__#__subclasshook__#im_class#</span>
<span style="color: #2aa198;">im_func#im_self'</span>
</pre>

<p>
当你通过class访问m1的时候，Python其实是调用MyClass.m1.__get__(None, MyClass)，
当你通过instance访问m1的是，调用MyClass.m1.__get__(m, MyClass)。
</p>


<pre class="src src-python">In [346]: MyClass.m1.__get__(<span style="color: #2aa198;">None</span>, MyClass)
Out[346]: &lt;unbound method MyClass.m1&gt;

In [347]: MyClass.m1.__get__(m, MyClass)
Out[354]: &lt;bound method MyClass.m1 of &lt;__main__.MyClass <span style="color: #859900;">object</span> at 0x1e49c10&gt;&gt;
</pre>


<p>
另外，如果你想调用m1，你会发现你总是失败。
</p>


<pre class="src src-python">In [357]: m.m1(1)
---------------------------------------------------------------------------
<span style="color: #b58900;">TypeError</span>                                 Traceback (most recent call last)
&lt;ipython-<span style="color: #859900;">input</span>-357-329146df192e&gt; <span style="color: #859900;">in</span> &lt;module&gt;()
----&gt; 1 m.m1(1)

<span style="color: #b58900;">TypeError</span>: m1() takes exactly 1 argument (2 given)

In [358]: MyClass.m1(1)
---------------------------------------------------------------------------
<span style="color: #b58900;">TypeError</span>                                 Traceback (most recent call last)
&lt;ipython-<span style="color: #859900;">input</span>-360-f35a4576c1b2&gt; <span style="color: #859900;">in</span> &lt;module&gt;()
----&gt; 1 MyClass.m1(1)

<span style="color: #b58900;">TypeError</span>: unbound method m1() must be called <span style="color: #859900;">with</span> MyClass instance <span style="color: #859900;">as</span> first
argument (got <span style="color: #859900;">int</span> instance instead)
</pre>

<p>
当你需要访问一个method，必须满足两个条件，首先必须bound，另外必须在定义的时候
明确定义self参数。Python在调用method的时候会隐式传递instance作为参数，如果你没
有明确声明self参数，调用就无法成功。如果你需要调用没有声明self参数的方法，参考
如下方式。
</p>


<pre class="src src-python">In [382]: MyClass.__dict__.get(<span style="color: #2aa198;">'m1'</span>)(1)
call m1 1

In [393]: m.m2(1)
call m2 1

In [394]: m.__class__.__dict__.get(<span style="color: #2aa198;">'m1'</span>)(1)
call m1 1

In [25]: m.m1.im_func(1)
call m1 1

In [26]: MyClass.m1.im_func(1)
call m1 1
</pre>

<p>
其他的方法是通过把m1声明为staticmethod或classmethod方法实现。
</p>

</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">staticmethod &amp; classmethod &amp; instancemethod</h2>
<div class="outline-text-2" id="text-5">

<p>TODO
</p>

</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">desctiptor protocol</h2>
<div class="outline-text-2" id="text-6">

<p>TODO
</p>

</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">scopes &amp; closure</h2>
<div class="outline-text-2" id="text-7">

<p>先看下面的代码片段
</p>


<pre class="src src-pythonn">funcs = []
def outer():
    for i in range(4):
        def inner():
            print i
        funcs.append(inner)
    return funcs

for f in outer():
    f()

In [126]: 3
3
3
3
</pre>

<p>
看到这个结果，是不是有点惊讶，我们期望的输出是“0，2，3，4”，这里输出的确全是3，
其实要理解这个首先你必须明白变量的范围和查找规则，变量可以定义在module、function
中，另外就是Python内建功能内，module对应的是global，function对应的是local，而内
建功能对应的是builtin。Python的查找规则简单来说叫LEGB，依次是
local-》enclosing-》global-》builtin。这里奇怪的冒出来一个enclosing，enclosing
这个概念其实是由于Python支持nest function，enclosing function的local变量对于
nest function就是enclosing的概念，具体到我们上面的例子inner是nest function，
outter就是inner的enclosing function。
</p>
<p>
回到上面的例子，funcs是global，outer是global，i对于outer是local（不准确说法），
但是对于inner来说是enclosing，当执行‘print i‘的时候，inner先找自己的local，没有
i定义，然后找enclosing，发现i，就终止查找，使用enclosing中的i。
</p>
<p>
但是一番解释之后，依然没有回答我们上面的问题，虽然找到了i，但是照理来说，i只有在
outter运行时才存在，而现在outer已经执行结束了，为啥inner还能使用i的值，并且都是3
呢？这就涉及到Python的另一个概念，closure：nest function会保存enclosing变量，这
就解释了为啥他依然能找到i了。至于为啥打印的都是3，这是因为，它只知道i这个变量，
对于i值的变化，他并不关心，他只能保存i的最终状态，当outter执行完的时候i的值已经
是3了，所以inner执行的时候答应的都是3。
</p>
<p>
避免上面类似的问题，你可以通过显示声明nest function变量
</p>


<pre class="src src-python"><span style="color: #268bd2;">funcs</span> = []
<span style="color: #859900;">def</span> <span style="color: #268bd2;">outer</span>():
    <span style="color: #859900;">for</span> i <span style="color: #859900;">in</span> <span style="color: #859900;">range</span>(4):
        <span style="color: #859900;">def</span> <span style="color: #268bd2;">inner</span>(i=i):
            <span style="color: #859900;">print</span> i
        funcs.append(inner)
    <span style="color: #859900;">return</span> funcs

<span style="color: #859900;">for</span> f <span style="color: #859900;">in</span> outer():
    f()

In [127]: 0
1
2
3
</pre>

<p>
这样对于inner来说，他有了一个local的i，当他执行的时候，就不再找enclosing了。
</p>
<p>
另外我们需要注意的是global，看下面代码：
</p>


<pre class="src src-python">demo_global.py
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">-*- coding: utf-8 -*-</span>
<span style="color: #268bd2;">x</span> = 10
<span style="color: #859900;">def</span> <span style="color: #268bd2;">f1</span>():
    <span style="color: #859900;">def</span> <span style="color: #268bd2;">inner</span>():
        <span style="color: #859900;">print</span> x
    <span style="color: #859900;">return</span> inner

demo_test.py
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">-*- coding: utf-8 -*-</span>
<span style="color: #859900;">import</span> demo_global

<span style="color: #268bd2;">x</span> = 30
<span style="color: #268bd2;">f2</span> = demo_global.f1()
f2()
</pre>

<p>
这里的输出是10，注意，global的范围就是module，所以在这里我们可以看到对于inner来
说，他的global限制在demo_global.py里面，如果你没有在demo_global中定义x，程序执
行会出错。
</p>

</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">Python分支</h2>
<div class="outline-text-2" id="text-8">


</div>

<div id="outline-container-8-1" class="outline-3">
<h3 id="sec-8-1">Stackless Python<sup><a class="footref" name="fnr-.5" href="#fn-.5">5</a></sup></h3>
<div class="outline-text-3" id="text-8-1">

<p>   先看看wikipedia上的解释：<br/>
   "Stackless microthreads are managed by the language interpreter itself,
   not the operating system kernel—context switching and task scheduling is
   done purely in the interpreter (these are thus also regarded as a form of
   green thread). This avoids many of the overheads of threads, because no mode
   switching between user mode and kernel mode needs to be done, and can
   significantly reduce CPU load in some high-concurrency situations.Due to the
   considerable number of changes in the source, Stackless Python cannot be
   installed on a preexisting Python installation as an extension or library.
   It is instead a complete Python distribution in itself. The majority of
   Stackless's features have also been implemented in PyPy, a self-hosting
   Python interpreter and JIT compiler." <br/>
   stackless是一个python的分支实现，主要的优势就是microthread，其实就是协程
   （coroutines / green threads），轻量级别的伪线程，采用栈方式实现协程切换，不
   会带来ContextSwitch，缺点是需要自己管理协程调用栈，stackless能实现10，0000级
   别的连接.
</p>



<pre class="example">from greenlet import greenlet
def test1():
    print 12
    gr2.switch()
    print 34

def test2():
    print 56
    gr1.switch()
    print 78   #not to be printed

gr1 = greenlet(test1)
gr2 = greenlet(test2)
gr1.switch()
</pre>


</div>

</div>

<div id="outline-container-8-2" class="outline-3">
<h3 id="sec-8-2">PyPy</h3>
<div class="outline-text-3" id="text-8-2">

<p>   实现了一个JIT，运行时转换python代码到机器码，主要关注在运行效率的提升，和原生
   python兼容，采用RPython（python的一个子集）实现，目前好像还没有看到那里有大规
   模的使用。关于PyPy和CPython的性能讨论可以看这里<sup><a class="footref" name="fnr-.6" href="#fn-.6">6</a></sup>
</p>

</div>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9">Django &amp; Flask</h2>
<div class="outline-text-2" id="text-9">

<p>  Django是一个整体解决方案，Python Web framework，实现快速开发网站，你不用做什么
  其他技术选择，比如templage engine、ORM等，社区很活跃。
  Flask是一个microframework，基于Werkzeug和Jinja2，Flash核心非常简单，不像Django
  帮你做了所有技术决策，缺省template engine用的是jinja。
</p>

</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10">Twisted &amp; Tornado &amp; gevent &amp; eventlet</h2>
<div class="outline-text-2" id="text-10">

<p>  Twisted是一个经典的非阻塞I/O框架，采用Callback方式实现异步调用，用户最广
  gevent和eventlet都是基于协程的异步框架（底下是greenlet），gevent是eventlet之后
  的一个项目，作者当时的一些需求不能被eventlet满足而重新设计的<sup><a class="footref" name="fnr-.7" href="#fn-.7">7</a></sup>，gevent底下
  的I/O异步框架是libevent/livev（epoll on linux / kqueue on FreeBSD / iocp on
  windows)，evenlet自己实现的。
</p>

</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11">Emacs &amp; Python</h2>
<div class="outline-text-2" id="text-11">

<p>  设置python-shell-extra-pythonpaths变量来增加额外的PYTHONPATH环境变量
</p>
</div>

<div id="outline-container-11-1" class="outline-3">
<h3 id="sec-11-1">ipdb</h3>
<div class="outline-text-3" id="text-11-1">

<p>   emacs里面的ipython需要运行%pdb打开断点模式，否则好像即使设置了断点也进不去，
   不清楚为什么，另外一些简单的命令记录一下：
</p><ul>
<li>s: step into
</li>
<li>n: step over
</li>
<li>c: continue to next breakpoint
</li>
<li>l: some more context
</li>
<li>a: all argument
</li>
<li>?s: help for command s
</li>
</ul>



</div>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12">一些必读的文章</h2>
<div class="outline-text-2" id="text-12">

<ul>
<li><a href="http://docs.python-guide.org/en/latest/">The Hitchhiker’s Guide to Python!</a>
</li>
<li><a href="http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained">The Python yield keyword explained</a>
</li>
<li><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python">How can I make a chain of function decorators in Python?</a>
</li>
<li><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">What is a metaclass in Python?</a>
</li>
<li><a href="http://nbviewer.ipython.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb">Python Descriptors Demystified</a>
</li>
<li><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python">Hidden features of Python</a>
</li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style Guide</a>
</li>
<li><a href="http://stackoverflow.com/questions/2709821/python-self-explained">Python 'self' explained</a>
</li>
<li><a href="http://docs.python.org/release/2.5/whatsnew/pep-343.html">PEP 343: The 'with' statement</a>
</li>
</ul>


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> <a href="http://docs.python.org/2/howto/unicode.html">Unicode HOWTO</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.2" href="#fnr-.2">2</a></sup> <a href="http://www.python.org/dev/peps/pep-0263/">PEP 0263</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.3" href="#fnr-.3">3</a></sup> <a href="https://developers.google.com/edu/python/regular-expressions">Google Python Regex</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.4" href="#fnr-.4">4</a></sup> <a href="https://ep2012.europython.eu/conference/talks/discovering-descriptors">Discovering Descriptors</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.5" href="#fnr-.5">5</a></sup> <a href="http://en.wikipedia.org/wiki/Stackless_Python">Stackless</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.6" href="#fnr-.6">6</a></sup> <a href="http://stackoverflow.com/questions/2591879/pypy-how-can-it-possibly-beat-cpython">Pypy - How can it possibly beat CPython</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.7" href="#fnr-.7">7</a></sup> <a href="http://blog.gevent.org/2010/02/27/why-gevent/">Comparing gevent to eventlet</a>
</p>



</div>
</div>

</div>
</div>
