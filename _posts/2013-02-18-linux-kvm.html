---
layout: post
categories: [tech]
title: "linux kvm notes"
description: "kvm介绍，包括配置，不使用libvirt层实现的命令行模式虚拟机操作，一些主要参数介绍，以及kvm虚拟机优化等，都是自己在使用上的一些记录，不定期动态更新。"
tags: [virtualization, hypervisor, kvm]
---


<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">背景信息</h2>
<div class="outline-text-2" id="text-1">

<p>本文档是自己在工作中对kvm使用上的一些记录，基于ubuntu 12.04 desktop操作系统，在我的工作笔记本电脑实现，机器带一块以太网卡和一块无线网卡，通过无线网卡连互联网。
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">文档目的</h2>
<div class="outline-text-2" id="text-2">

<p>介绍kvm，包括配置，不使用libvirt层实现的命令行模式虚拟机操作，一些主要参数介绍，以及kvm虚拟机优化等。
</p>
<p>
在文档中，我会利用kvm命令行方式，实现一个nat模式的虚拟化网络，虚拟机通过nat访问外网，外网无法访问虚拟机。
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">kvm安装</h2>
<div class="outline-text-2" id="text-3">

<p>在ubuntu下需要安装的kvm包：
</p>


<pre class="example">sudo apt-get install kvm uml-utilities bridge-utils
</pre>


<p>
加载kvm模块：
</p>


<pre class="example">modprobe kvm-intel
</pre>

<p>
可以先确认是否加载，没有的话可以自己加载（我用的是intel cpu，如果是amd可以通过kvm-amd加载），修改/etc/modules，在里面添加如下行，使其自动加载：
</p>


<pre class="example">kvm_intel
</pre>


<p>
如果需要kvm nest功能，上面行需要修改为：
</p>


<pre class="example">kvm_intel nested=1
</pre>


<p>
同时guest启动命令需要带上如下参数：
</p>


<pre class="example">-cpu host 或者 -cpu qemu64,+vmx
</pre>


</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">通过linux bridge 配置nat模式虚拟网络</h2>
<div class="outline-text-2" id="text-4">

<p>在这里没有使用libvirt，其实用libvirt操作kvm非常方便，这里没用主要是自己希望了解一下kvm的一些细节，包括虚拟网络创建、参数使用和优化参数等等。
</p>
<p>
虚拟网络创建通过bridge实现，相比xen的虚拟网络实现，kvm要简单的多，基本就是创建一个bridge，但是不用绑定到物理网卡上，配置nat策略，同时启用dnsmasq负责guest dhcp即可，实现方式可以直接修改/etc/qemu-ifup脚本内容如下：
</p>


<pre class="example">#!/bin/sh
#
# Copyright IBM, Corp. 2010
#
# Authors:
#  Anthony Liguori &lt;aliguori@us.ibm.com&gt;
#
# This work is licensed under the terms of the GNU GPL, version 2.  See
# the COPYING file in the top-level directory.

# Set to the name of your bridge
BRIDGE=virbr0

# Network information
NETWORK=192.168.122.0
NETMASK=255.255.255.0
GATEWAY=192.168.122.1
DHCPRANGE=192.168.122.2,192.168.122.254

# Optionally parameters to enable PXE support
TFTPROOT=
BOOTP=

do_brctl() {
    brctl "$@"
}

do_ifconfig() {
    ifconfig "$@"
}

do_dd() {
    dd "$@"
}

do_iptables_restore() {
    iptables-restore "$@"
}

do_dnsmasq() {
    dnsmasq "$@"
}

check_bridge() {
    if do_brctl show | grep "^$1" &gt; /dev/null 2&gt; /dev/null; then
    return 1
    else
    return 0
    fi
}

create_bridge() {
    do_brctl addbr "$1"
    do_brctl stp "$1" off
    do_brctl setfd "$1" 0
    do_ifconfig "$1" "$GATEWAY" netmask "$NETMASK" up
}

enable_ip_forward() {
    echo 1 | do_dd of=/proc/sys/net/ipv4/ip_forward &gt; /dev/null
}

add_filter_rules() {
do_iptables_restore &lt;&lt;EOF
# Generated by iptables-save v1.3.6 on Fri Aug 24 15:20:25 2007
*nat
:PREROUTING ACCEPT [61:9671]
:POSTROUTING ACCEPT [121:7499]
:OUTPUT ACCEPT [132:8691]
-A POSTROUTING -s $NETWORK/$NETMASK -j MASQUERADE
COMMIT
# Completed on Fri Aug 24 15:20:25 2007
# Generated by iptables-save v1.3.6 on Fri Aug 24 15:20:25 2007
*filter
:INPUT ACCEPT [1453:976046]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [1605:194911]
-A INPUT -i $BRIDGE -p tcp -m tcp --dport 67 -j ACCEPT
-A INPUT -i $BRIDGE -p udp -m udp --dport 67 -j ACCEPT
-A INPUT -i $BRIDGE -p tcp -m tcp --dport 53 -j ACCEPT
-A INPUT -i $BRIDGE -p udp -m udp --dport 53 -j ACCEPT
-A FORWARD -i $1 -o $1 -j ACCEPT
-A FORWARD -s $NETWORK/$NETMASK -i $BRIDGE -j ACCEPT
-A FORWARD -d $NETWORK/$NETMASK -o $BRIDGE -m state --state RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o $BRIDGE -j REJECT --reject-with icmp-port-unreachable
-A FORWARD -i $BRIDGE -j REJECT --reject-with icmp-port-unreachable
COMMIT
# Completed on Fri Aug 24 15:20:25 2007
EOF
}

start_dnsmasq() {
    do_dnsmasq \
    --strict-order \
    --except-interface=lo \
    --interface=$BRIDGE \
    --listen-address=$GATEWAY \
    --bind-interfaces \
    --dhcp-range=$DHCPRANGE \
    --conf-file="" \
    --pid-file=/var/run/qemu-dnsmasq-$BRIDGE.pid \
    --dhcp-leasefile=/var/run/qemu-dnsmasq-$BRIDGE.leases \
    --dhcp-no-override \
    ${TFTPROOT:+"--enable-tftp"} \
    ${TFTPROOT:+"--tftp-root=$TFTPROOT"} \
    ${BOOTP:+"--dhcp-boot=$BOOTP"}
}

setup_bridge_nat() {
    if check_bridge "$1" ; then
    create_bridge "$1"
    enable_ip_forward
    add_filter_rules "$1"
    start_dnsmasq "$1"
    fi
}

setup_bridge_vlan() {
    if check_bridge "$1" ; then
    create_bridge "$1"
    start_dnsmasq "$1"
    fi
}

setup_bridge_nat "$BRIDGE"

if test "$1" ; then
    do_ifconfig "$1" 0.0.0.0 up
    do_brctl addif "$BRIDGE" "$1"
fi
</pre>


<p>
这样当你在启动一个kvm guest的时候，就会自动创建一个nat模式的网络，bridge名字是virbr0，guest通过dhcp获得一个192.168.122.0/24网段的ip地址，可以联通互联网。
</p>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">创建虚拟机</h2>
<div class="outline-text-2" id="text-5">

<p>以创建centos虚拟机为例，你首先需要创建一个磁盘镜像文件，也可以是一个块设备：
</p>


<pre class="example">$kvm-img create -f raw centos.img 10G
</pre>


<p>
这里我们创建了一个raw格式的磁盘镜像文件，大小为10g，注意文件实际并不占用10g空间，而是按需分配<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>。关于文件格式的区别简单描述如下：
</p>
<ul>
<li>raw格式在文件镜像中性能最优，但是功能支持也少，比如不支持快照，精简分配需要文件系统支持holes。
</li>
<li>qcow2是功能丰富，精简配置无须文件系统支持holes，支持压缩和加密，支持快照和backing_file功能。
</li>
<li>vdi/vmdk/vpc，分别对应virtualbox/vmware/ms virtualpc
</li>
</ul>


<p>
当然你也可以通过lvm来分配一个lv给虚拟机用，块设备性能最佳，当然也有很多问题，可维护性一般，而且一般也不支持精简配置，其他的分布式块系统比如sheepdog这里就不多说了。最终目的只有一个，给虚拟机提供磁盘块安装操作系统。
</p>
<p>
有了磁盘镜像文件之后，你就可以启动虚拟机了，由于我们这里直接通过原始的命令行启动虚拟机，不需要创建额外的xml配置文件。启动虚拟机涉及到组成计算机的几个核心组件：cpu/ram/storage/network/cdrom/soundcard/display，我们一一描述：
</p>
<ul>
<li>cpu

<p>
  可以通过下面命令查看kvm支持的cpu类型：
</p>


<pre class="example">kvm -cpu ?
</pre>


<p>
  主要涉及到一些指令集多少问题，qemu32/qemu64兼容性最好，如果你需要支持特定的指令集，添加即可，比如你需要添加vt指令集，直接"qemu64,+vmx"即可<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup>
</p>
<p>
  如果你的所有主机CPU一样，可以直接用“-cpu host"，这样虚拟机的cpu和宿主机一致，性能最佳。通过-smp参数设置多cpu支持，通过-numa参数模拟多节点numa。
</p>
</li>
<li>storage

<p>
  通过下面参数设置：
</p>


<pre class="example">-drive file=centos.img if=virtio,cache=writeback,aio=native
</pre>


<p>
  这里涉及到两个参数if和cache:
</p><ol>
<li>if用来指定驱动类型，这里我们用的是virtio, virtio绕开qemu模拟层，是优化io的重要部分，当然前提是你的guest os需要支持virtio，安装对应的驱动。

</li>
<li>cache指定缓存模式

<ul>
<li>缺省是writethough，读写缓存，写回通知。

</li>
<li>writeback也是读写缓存，只是不保证持久化到磁盘，当主机掉电的时候，有丢失数据的风险。

</li>
<li>其他还有none，不使用缓存, 如果你使用块设备, 建议使用该选项, 减少数据在总线上的拷贝开销。

</li>
<li>directsync, 和writethough的区别在于写不缓存, 类似sync io操作。

</li>
<li>unsafe最不安全，估计就是连元数据修改都不用保存，具体我也没仔细看。

</li>
</ul>

<p>     另外对于磁盘镜像文件模式，还需要考虑块对齐问题，一般保持和宿主机同样的块大小，分区块对齐，否则可能引发跨块的io操作，影响io性能。
</p>
</li>
<li>aio指定io的模式，支持thread和native，native性能更佳。

</li>
</ol>

</li>
<li>network

<p>
  通过下面参数设置：
</p>


<pre class="example">-net nic,vlan=0,model=virtio,macaddr=DE:AD:BE:EF:FC:70 \
-net tap,vlan=0,vhost=on \
</pre>


<p>
  缺省qemu使用user mode网络，完全和宿主机隔离，性能差，通常都需要使用tap模式，同时打开vhost-net特性，vhost-net完全bypass qemu，并且运行在kernel层，能大大降低cs的开销，性能接近宿主机网络。
</p>
<p>
  同时采用virtio半虚拟化驱动，相比模拟驱动性能提升明显，前提同样是guest os需要支持virtio驱动。同时打开两者获取最好的网络性能。另外注意vhost需要加载vhost_net模块：
</p>


<pre class="example">modprobe vhost_net
</pre>


<p>
  确保使用了vhost_net特性，你只需在启动guest的时候，查看是否有vhost线程存在：
</p>


<pre class="example">ps -ef | grep vhost- | grep -v grep
root      1563     2  0 Feb18 ?        00:00:00 [vhost-1561]
</pre>


</li>
<li>qemu monitor

<p>
  qemu和guest交互的一个控制台，支持多种模式交互，比如unix socket，tcp socket等，通过下面参数设置：
</p>


<pre class="example">-monitor unix:/home/tacy/vm/monitor/centos.monitor,server,nowait
</pre>


<p>
  上面是unix socket模式, 这样你可以直接发送system_powerdown指令关机了，相当于按power键；system_reset相当于按reset键，这个要小心:
</p>


<pre class="example">socat - UNIX-CONNECT:/home/tacy/vm/monitor/centos.monitor
</pre>


<p>
  直接关闭虚拟机可以通过下面指令:
</p>


<pre class="example">echo system_reset | socat - UNIX-CONNECT:/home/tacy/vm/monitor/centos.monitor
</pre>


</li>
<li>other

<p>
  时间同步可以采用ntp或者"-rtc base=localtime,clock=vm", vnc鼠标同步用"-usbdevice tablet", pass-through usb口用"-usbdevice host:19d2:0117", 关闭console用"-nographic".
</p></li>
</ul>


<p>
下面是我的启动命令：
</p>



<pre class="example">sudo kvm -m 2048 -smp 2 -cpu host -enable-kvm -boot c \
    -drive file=/home/tacy/vm/software/CentOS-6.3-x86_64-bin-DVD1.iso,media=cdrom -boot d \
    -drive file=centos.img,if=virtio,cache=none,aio=native \
    -net nic,vlan=0,model=virtio,macaddr=DE:AD:BE:EF:FC:70 \
    -net tap,vlan=0,vhost=on \
    -soundhw es1370 \
    -rtc base=localtime,clock=vm \
    -usbdevice host:19d2:0117 -usbdevice tablet \
    -monitor unix:/home/tacy/vm/monitor/centos.monitor,server,nowait \
    -vga std -nographic -vnc :0 \
    &gt;/dev/null 2&gt;&amp;1 &amp;
</pre>


<p>
上面我指定了光驱,和从光驱启动，这样你通过vnc就可以连接上虚拟机，进行系统安装了。
</p>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">windows guest</h2>
<div class="outline-text-2" id="text-6">



</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1">virtio</h3>
<div class="outline-text-3" id="text-6-1">

<p>如果把系统安装在virtio磁盘上，安装的时候必须指定驱动，否则找不到磁盘，驱动下载地址可以参考<a href="http://www.linux-kvm.org/page/WindowsGuestDrivers">Windows guest drivers</a>
</p>
</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2">关机</h3>
<div class="outline-text-3" id="text-6-2">

<p>gpedit.msc  (允许无用户登入关机）
</p>


<pre class="example">Computer Configuration\Windows Settings\Security Settings\Local Policies\Security Options\Shutdown: Allow system to be shut down without having to log on
</pre>


<p>
regedit  （有用户登入时，提示超时关机）
</p>


<pre class="example">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows]  "ShutdownWarningDialogTimeout"=dword:00000001
</pre>


</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">base image &amp; snapshot</h2>
<div class="outline-text-2" id="text-7">


</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1">base image<sup><a class="footref" name="fnr.3" href="#fn.3">3</a></sup></h3>
<div class="outline-text-3" id="text-7-1">

<p>base image简单可以理解为模板，举个例子，你在部署公司的虚拟化环境，公司的所有的系统都跑在centos上，只是上面配置的应用各有不同，有c开发的，有java开发的等等，简单来说，你会先安装一个base image
</p>


<pre class="example">$kvm-img create -f qcow2 centos.qcow2 10g
$kvm -drive file=centos.qcow2 -m 1024 -boot d -drive file=centos.iso,media=cdrom
</pre>


<p>
安装完操作系统和相应补丁之后，你可以从你的base image创建一个新的image:
</p>


<pre class="example">$kvm-img create -b centos.qcow2 -f qcow2 centos-clone.qcow2
</pre>


<p>
新的image文件并不会实际占用空间，他链接在base image上，只有修改之后，才会通过copy on write方式保存修改内容到新的image文件：
</p>


<pre class="example">$kvm-img info centos-clone.qcow2
image: centos-clone.qcow2
file format: qcow2
virtual size: 10G (10737418240 bytes)
disk size: 136K
cluster_size: 65536
backing file: centos.qcow2 (actual path: centos.qcow2)
</pre>


<p>
你可以从centos-clone.qcow2启动虚拟机，然后完成配置，然后重新rebase该clone，生成新的base image:
</p>


<pre class="example">kvm-img convert centos-clone.qcow2 -O qcow2 centos-base-java.qcow2
</pre>


</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2">移动base image</h3>
<div class="outline-text-3" id="text-7-2">

<p>有时候，为了运维的目的，你可能需要移动base image, 这个时候你需要重新rebase所有相关的clone，否则clone就会出错：
</p>


<pre class="example">kvm-img rebase -f qcow2 -u -b centos54.img -F raw centos-clone.qcow2
</pre>


</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3">snapshot<sup><a class="footref" name="fnr.4" href="#fn.4">4</a></sup></h3>
<div class="outline-text-3" id="text-7-3">

<p>快照是虚拟机一个常用的功能，你可以利用快照功能来保留某个时间点的虚拟机状态，方便虚拟机回滚。离线快照参考man手册即可。在线快照通过monitor或者QMP实现。
</p>
</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">其他相关</h2>
<div class="outline-text-2" id="text-8">


</div>

<div id="outline-container-8-1" class="outline-3">
<h3 id="sec-8-1">查看虚拟机ip地址</h3>
<div class="outline-text-3" id="text-8-1">

<p>如果虚拟机很少，简单通过“arp -an”查看即可，如果虚拟机很多，你不容易找到ip和mac的对应关系，需要自己写脚本去实现了<sup><a class="footref" name="fnr.5" href="#fn.5">5</a></sup>
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> sparse file：<a href="http://en.wikipedia.org/wiki/Sparse_file">http://en.wikipedia.org/wiki/Sparse\_file</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> tuning kvm: <a href="http://www.linux-kvm.org/page/Tuning_KVM">http://www.linux-kvm.org/page/Tuning\_KVM</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn.3" href="#fnr.3">3</a></sup> how to use base image: <a href="http://www.linux-kvm.com/content/how-you-can-use-qemukvm-base-images-be-more-productive-part-1">http://www.linux-kvm.com/content/how-you-can-use-qemukvm-base-images-be-more-productive-part-1</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn.4" href="#fnr.4">4</a></sup> kvm snapshot: <a href="http://wiki.qemu.org/Features/Snapshots">http://wiki.qemu.org/Features/Snapshots</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn.5" href="#fnr.5">5</a></sup> find the ip address of a vm: <a href="http://rwmj.wordpress.com/2010/10/26/tip-find-the-ip-address-of-a-virtual-machine/">http://rwmj.wordpress.com/2010/10/26/tip-find-the-ip-address-of-a-virtual-machine/</a>
</p>


</div>
</div>
</div>

</div>
</div>
