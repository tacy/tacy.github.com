---
layout: post
title: "openstack notes"
description: "Openstack的一些基本信息，自己的了解，认为好的一些资源收集，记录下来。"
categories: [tech]
tags: [openstack]
---

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Swift ring builder</a>
<ul>
<li><a href="#sec-1-1">1.1 add device</a></li>
<li><a href="#sec-1-2">1.2 rebalance</a></li>
</ul>
</li>
<li><a href="#sec-2">2 经典文章</a></li>
<li><a href="#sec-3">3 nova develop environment</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Swift ring builder</h2>
<div class="outline-text-2" id="text-1">

<p>  读了一下ringbuilder代码，简单记录一下，免的忘了。
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">add device</h3>
<div class="outline-text-3" id="text-1-1">

<p>   添加device的时候可以指定每个device的meta信息和replication ip，Swift会给每
   个device一个id，这个id会一直递增，也就是说新增加的device的id总是比device的id
   大，不会重用id
</p>


<pre class="src src-python"><span style="color: #859900;">if</span> <span style="color: #2aa198;">'id'</span> <span style="color: #859900;">not</span> <span style="color: #859900;">in</span> dev:&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">dev</span>[<span style="color: #2aa198;">'id'</span>] = 0&#57344;&#57345;&#57345;
    <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>.devs:&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">dev</span>[<span style="color: #2aa198;">'id'</span>] = <span style="color: #859900;">max</span>(d[<span style="color: #2aa198;">'id'</span>] <span style="color: #859900;">for</span> d <span style="color: #859900;">in</span> <span style="color: #859900;">self</span>.devs <span style="color: #859900;">if</span> d) + 1&#57344;&#57345;&#57345;
<span style="color: #859900;">if</span> dev[<span style="color: #2aa198;">'id'</span>] &lt; <span style="color: #859900;">len</span>(<span style="color: #859900;">self</span>.devs) <span style="color: #859900;">and</span> <span style="color: #859900;">self</span>.devs[dev[<span style="color: #2aa198;">'id'</span>]] <span style="color: #859900;">is</span> <span style="color: #859900;">not</span> <span style="color: #2aa198;">None</span>:&#57344;&#57345;&#57345;
    <span style="color: #859900;">raise</span> exceptions.DuplicateDeviceError(&#57344;&#57345;&#57345;
        <span style="color: #2aa198;">'Duplicate device id: %d'</span> % dev[<span style="color: #2aa198;">'id'</span>])&#57344;&#57345;&#57345;
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">Add holes to self.devs to ensure self.devs[dev['id']] will be the dev</span>&#57344;&#57345;&#57345;
<span style="color: #859900;">while</span> dev[<span style="color: #2aa198;">'id'</span>] &gt;= <span style="color: #859900;">len</span>(<span style="color: #859900;">self</span>.devs):&#57344;&#57345;&#57345;
    <span style="color: #859900;">self</span>.devs.append(<span style="color: #2aa198;">None</span>)&#57344;&#57345;&#57345;
</pre>


<p>
   weight和Part之间的关系计算很简单
</p>


<pre class="src src-python"><span style="color: #859900;">return</span> <span style="color: #859900;">self</span>.parts * <span style="color: #859900;">self</span>.replicas / \&#57344;&#57345;&#57345;
    <span style="color: #859900;">sum</span>(d[<span style="color: #2aa198;">'weight'</span>] <span style="color: #859900;">for</span> d <span style="color: #859900;">in</span> <span style="color: #859900;">self</span>._iter_devs())&#57344;&#57345;&#57345;
</pre>


<p>
   在添加device的时候，会重新计算device所期望的Part（原有device需要减去已分配）
   ，这个值很关键，后面part和device的映射会根据这个值确定分配优先级（
   parts<sub>wanted大优先级高）</sub>
</p>


<pre class="src src-python"><span style="color: #859900;">for</span> dev <span style="color: #859900;">in</span> <span style="color: #859900;">self</span>._iter_devs():&#57344;&#57345;&#57345;
    <span style="color: #859900;">if</span> <span style="color: #859900;">not</span> dev[<span style="color: #2aa198;">'weight'</span>]:&#57344;&#57345;&#57345;
        <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">With no weight, that means we wish to "drain" the device. So</span>&#57344;&#57345;&#57345;
        <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">we set the parts_wanted to a really large negative number to</span>&#57344;&#57345;&#57345;
        <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">indicate its strong desire to give up everything it has.</span>&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">dev</span>[<span style="color: #2aa198;">'parts_wanted'</span>] = -<span style="color: #859900;">self</span>.parts * <span style="color: #859900;">self</span>.replicas&#57344;&#57345;&#57345;
    <span style="color: #859900;">else</span>:&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">dev</span>[<span style="color: #2aa198;">'parts_wanted'</span>] = \&#57344;&#57345;&#57345;
            <span style="color: #859900;">int</span>(weight_of_one_part * dev[<span style="color: #2aa198;">'weight'</span>]) - dev[<span style="color: #2aa198;">'parts'</span>]&#57344;&#57345;&#57345;
</pre>


<p>
   添加device并不会导致数据迁移，必须显示调用rebalance才会执行平衡操作。
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">rebalance</h3>
<div class="outline-text-3" id="text-1-2">

<p>   relalance入口
</p>


<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">rebalance</span>(<span style="color: #859900;">self</span>, seed=<span style="color: #2aa198;">None</span>):&#57344;&#57345;&#57345;
    <span style="color: #2aa198;">"""</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    Rebalance the ring.</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    This is the main work function of the builder, as it will assign and</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    reassign partitions to devices in the ring based on weights, distinct</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    zones, recent reassignments, etc.</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    The process doesn't always perfectly assign partitions (that'd take a</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    lot more analysis and therefore a lot more time -- I had code that did</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    that before). Because of this, it keeps rebalancing until the device</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    skew (number of partitions a device wants compared to what it has) gets</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    below 1% or doesn't change by more than 1% (only happens with ring that</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    can't be balanced no matter what -- like with 3 zones of differing</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    weights with replicas set to 3).</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    :returns: (number_of_partitions_altered, resulting_balance)</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    """</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
    <span style="color: #859900;">if</span> seed:&#57344;&#57345;&#57345;
        random.seed(seed)&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#22914;&#26524;&#20026;&#31354;&#65292;&#34920;&#31034;&#31532;&#19968;&#27425;&#20570;balance,&#36825;&#37324;&#30340;&#25805;&#20316;&#21644;&#37325;&#20570;balance&#24046;&#19981;&#22810;</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">self</span>._ring = <span style="color: #2aa198;">None</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>._last_part_moves_epoch <span style="color: #859900;">is</span> <span style="color: #2aa198;">None</span>:&#57344;&#57345;&#57345;
        <span style="color: #859900;">self</span>._initial_balance()&#57344;&#57345;&#57345;
        <span style="color: #859900;">self</span>.devs_changed = <span style="color: #2aa198;">False</span>&#57344;&#57345;&#57345;
        <span style="color: #859900;">return</span> <span style="color: #859900;">self</span>.parts, <span style="color: #859900;">self</span>.get_balance()&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">retval</span> = 0&#57344;&#57345;&#57345;
    <span style="color: #859900;">self</span>._update_last_part_moves()&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">last_balance</span> = 0&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#25910;&#38598;&#21738;&#20123;part&#38656;&#35201;&#20998;&#37197;dev</span>&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">new_parts</span>, <span style="color: #268bd2;">removed_part_count</span> = <span style="color: #859900;">self</span>._adjust_replica2part2dev_size()&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">retval</span> += removed_part_count&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#25191;&#34892;&#20998;&#37197;&#25805;&#20316;</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">self</span>._reassign_parts(new_parts)&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">retval</span> += <span style="color: #859900;">len</span>(new_parts)&#57344;&#57345;&#57345;
    <span style="color: #859900;">while</span> <span style="color: #2aa198;">True</span>:&#57344;&#57345;&#57345;
        <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#32479;&#35745;&#31227;&#38500;&#30340;device&#25345;&#26377;&#30340;part,&#21644;&#36229;&#36733;&#30340;device&#65292;&#25191;&#34892;&#20998;&#37197;&#25805;&#20316;,&#37325;&#22797;&#25191;&#34892;</span>&#57344;&#57345;&#57345;
        <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">balance&#65292;&#30452;&#21040;&#24179;&#34913;</span>&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">reassign_parts</span> = <span style="color: #859900;">self</span>._gather_reassign_parts()&#57344;&#57345;&#57345;
        <span style="color: #859900;">self</span>._reassign_parts(reassign_parts)&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">retval</span> += <span style="color: #859900;">len</span>(reassign_parts)&#57344;&#57345;&#57345;
        <span style="color: #859900;">while</span> <span style="color: #859900;">self</span>._remove_devs:&#57344;&#57345;&#57345;
            <span style="color: #859900;">self</span>.devs[<span style="color: #859900;">self</span>._remove_devs.pop()[<span style="color: #2aa198;">'id'</span>]] = <span style="color: #2aa198;">None</span>&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">balance</span> = <span style="color: #859900;">self</span>.get_balance()&#57344;&#57345;&#57345;
        <span style="color: #859900;">if</span> balance &lt; 1 <span style="color: #859900;">or</span> <span style="color: #859900;">abs</span>(last_balance - balance) &lt; 1 <span style="color: #859900;">or</span> \&#57344;&#57345;&#57345;
                retval == <span style="color: #859900;">self</span>.parts:&#57344;&#57345;&#57345;
            <span style="color: #859900;">break</span>&#57344;&#57345;&#57345;
        last_balance = balance&#57344;&#57345;&#57345;
    <span style="color: #859900;">self</span>.devs_changed = <span style="color: #2aa198;">False</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">self</span>.version += 1&#57344;&#57345;&#57345;
    <span style="color: #859900;">return</span> retval, balance&#57344;&#57345;&#57345;
</pre>


<p>
   <sub>reassign</sub><sub>parts</sub>()完成核心的part到dev的映射
</p>


<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">_reassign_parts</span>(<span style="color: #859900;">self</span>, reassign_parts):&#57344;&#57345;&#57345;
    <span style="color: #2aa198;">"""</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    For an existing ring data set, partitions are reassigned similarly to</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    the initial assignment. The devices are ordered by how many partitions</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    they still want and kept in that order throughout the process. The</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    gathered partitions are iterated through, assigning them to devices</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    according to the "most wanted" while keeping the replicas as "far</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    apart" as possible. Two different regions are considered the</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    farthest-apart things, followed by zones, then different ip/port pairs</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    within a zone; the least-far-apart things are different devices with</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    the same ip/port pair in the same zone.</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    If you want more replicas than devices, you won't get all your</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    replicas.</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    :param reassign_parts: An iterable of (part, replicas_to_replace)</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">                           pairs. replicas_to_replace is an iterable of the</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">                           replica (an int) to replace for that partition.</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">                           replicas_to_replace may be shared for multiple</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">                           partitions, so be sure you do not modify it.</span>&#57344;&#57345;&#57345;
<span style="color: #2aa198;">    """</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">for</span> dev <span style="color: #859900;">in</span> <span style="color: #859900;">self</span>._iter_devs():&#57344;&#57345;&#57345;
        <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#29983;&#25104;&#25353;&#29031;parts_wanted&#25490;&#24207;&#30340;key</span>&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">dev</span>[<span style="color: #2aa198;">'sort_key'</span>] = <span style="color: #859900;">self</span>._sort_key_for(dev)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">available_devs</span> = \&#57344;&#57345;&#57345;
        <span style="color: #859900;">sorted</span>((d <span style="color: #859900;">for</span> d <span style="color: #859900;">in</span> <span style="color: #859900;">self</span>._iter_devs() <span style="color: #859900;">if</span> d[<span style="color: #2aa198;">'weight'</span>]),&#57344;&#57345;&#57345;
               key=<span style="color: #859900;">lambda</span> x: x[<span style="color: #2aa198;">'sort_key'</span>])&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">tier2devs</span> = defaultdict(<span style="color: #859900;">list</span>)&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">tier2sort_key</span> = defaultdict(<span style="color: #859900;">list</span>)&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">max_tier_depth</span> = 0&#57344;&#57345;&#57345;
    <span style="color: #859900;">for</span> dev <span style="color: #859900;">in</span> available_devs:&#57344;&#57345;&#57345;
        <span style="color: #859900;">for</span> tier <span style="color: #859900;">in</span> tiers_for_dev(dev):&#57344;&#57345;&#57345;
            <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#29983;&#25104;tier&#21644;dev&#30340;&#20851;&#31995;&#32467;&#26500;&#65292;&#21253;&#25324;</span>&#57344;&#57345;&#57345;
            <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">{(region)[dev]}&#65292;{(region,zone):[dev]}</span>&#57344;&#57345;&#57345;
            <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">{(region,zone,machine):[dev]}</span>&#57344;&#57345;&#57345;
            <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">{(region,zone,machine,id):[dev]}</span>&#57344;&#57345;&#57345;
            tier2devs[tier].append(dev)  <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">&lt;-- starts out sorted!</span>&#57344;&#57345;&#57345;
            tier2sort_key[tier].append(dev[<span style="color: #2aa198;">'sort_key'</span>])&#57344;&#57345;&#57345;
            <span style="color: #859900;">if</span> <span style="color: #859900;">len</span>(tier) &gt; max_tier_depth:&#57344;&#57345;&#57345;
                <span style="color: #268bd2;">max_tier_depth</span> = <span style="color: #859900;">len</span>(tier)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#29983;&#25104;tiger&#21644;children&#20851;&#31995;&#65292;{():[region]}</span>&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">{(region):[(region,zone)]}</span>&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">{(region,zone):[(region,zone,machine)]</span>&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">{(region,zone,machine):[region,zone,machine,devid]}</span>&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">tier2children_sets</span> = build_tier_tree(available_devs)&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">tier2children</span> = defaultdict(<span style="color: #859900;">list</span>)&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">tier2children_sort_key</span> = {}&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">tiers_list</span> = [()]&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">depth</span> = 1&#57344;&#57345;&#57345;
    <span style="color: #859900;">while</span> depth &lt;= max_tier_depth:&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">new_tiers_list</span> = []&#57344;&#57345;&#57345;
        <span style="color: #859900;">for</span> tier <span style="color: #859900;">in</span> tiers_list:&#57344;&#57345;&#57345;
            <span style="color: #268bd2;">child_tiers</span> = <span style="color: #859900;">list</span>(tier2children_sets[tier])&#57344;&#57345;&#57345;
            child_tiers.sort(key=<span style="color: #859900;">lambda</span> t: tier2sort_key[t][-1])&#57344;&#57345;&#57345;
            <span style="color: #268bd2;">tier2children</span>[tier] = child_tiers&#57344;&#57345;&#57345;
            <span style="color: #268bd2;">tier2children_sort_key</span>[tier] = <span style="color: #859900;">map</span>(&#57344;&#57345;&#57345;
                <span style="color: #859900;">lambda</span> t: tier2sort_key[t][-1], child_tiers)&#57344;&#57345;&#57345;
            new_tiers_list.extend(child_tiers)&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">tiers_list</span> = new_tiers_list&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">depth</span> += 1&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#36941;&#21382;tier2children&#20851;&#31995;&#65292;&#25214;&#26368;&#38656;&#35201;&#20998;&#37197;&#30340;dev</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">for</span> part, replace_replicas <span style="color: #859900;">in</span> reassign_parts:&#57344;&#57345;&#57345;
        <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">Gather up what other tiers (regions, zones, ip/ports, and</span>&#57344;&#57345;&#57345;
        <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">devices) the replicas not-to-be-moved are in for this part.</span>&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">other_replicas</span> = defaultdict(<span style="color: #859900;">int</span>)&#57344;&#57345;&#57345;
        <span style="color: #268bd2;">unique_tiers_by_tier_len</span> = defaultdict(<span style="color: #859900;">set</span>)&#57344;&#57345;&#57345;
        <span style="color: #859900;">for</span> replica <span style="color: #859900;">in</span> <span style="color: #859900;">self</span>._replicas_for_part(part):&#57344;&#57345;&#57345;
            <span style="color: #859900;">if</span> replica <span style="color: #859900;">not</span> <span style="color: #859900;">in</span> replace_replicas:&#57344;&#57345;&#57345;
                <span style="color: #268bd2;">dev</span> = <span style="color: #859900;">self</span>.devs[<span style="color: #859900;">self</span>._replica2part2dev[replica][part]]&#57344;&#57345;&#57345;
                <span style="color: #859900;">for</span> tier <span style="color: #859900;">in</span> tiers_for_dev(dev):&#57344;&#57345;&#57345;
                    <span style="color: #268bd2;">other_replicas</span>[tier] += 1&#57344;&#57345;&#57345;
                    unique_tiers_by_tier_len[<span style="color: #859900;">len</span>(tier)].add(tier)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
        <span style="color: #859900;">for</span> replica <span style="color: #859900;">in</span> replace_replicas:&#57344;&#57345;&#57345;
            <span style="color: #268bd2;">tier</span> = ()&#57344;&#57345;&#57345;
            <span style="color: #268bd2;">depth</span> = 1&#57344;&#57345;&#57345;
            <span style="color: #859900;">while</span> depth &lt;= max_tier_depth:&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">Order the tiers by how many replicas of this</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">partition they already have. Then, of the ones</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">with the smallest number of replicas, pick the</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">tier with the hungriest drive and then continue</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">searching in that subtree.</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;">#</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">There are other strategies we could use here,</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">such as hungriest-tier (i.e. biggest</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">sum-of-parts-wanted) or picking one at random.</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">However, hungriest-drive is what was used here</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">before, and it worked pretty well in practice.</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;">#</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">Note that this allocator will balance things as</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">evenly as possible at each level of the device</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">layout. If your layout is extremely unbalanced,</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">this may produce poor results.</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;">#</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">This used to be a cute, recursive function, but it's been</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">unrolled for performance.</span>&#57344;&#57345;&#57345;
                <span style="color: #268bd2;">candidate_tiers</span> = tier2children[tier]&#57344;&#57345;&#57345;
                <span style="color: #268bd2;">candidates_with_replicas</span> = \&#57344;&#57345;&#57345;
                    unique_tiers_by_tier_len[<span style="color: #859900;">len</span>(tier) + 1]&#57344;&#57345;&#57345;
                <span style="color: #859900;">if</span> <span style="color: #859900;">len</span>(candidate_tiers) &gt; <span style="color: #859900;">len</span>(candidates_with_replicas):&#57344;&#57345;&#57345;
                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">There exists at least one tier with 0 other replicas,</span>&#57344;&#57345;&#57345;
                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">so work backward among the candidates, accepting the</span>&#57344;&#57345;&#57345;
                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">first which isn't in other_replicas.</span>&#57344;&#57345;&#57345;
                    <span style="color: #586e75; font-style: italic;">#</span>&#57344;&#57345;&#57345;
                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">This optimization is to avoid calling the min()</span>&#57344;&#57345;&#57345;
                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">below, which is expensive if you've got thousands of</span>&#57344;&#57345;&#57345;
                    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">drives.</span>&#57344;&#57345;&#57345;
                    <span style="color: #859900;">for</span> t <span style="color: #859900;">in</span> <span style="color: #859900;">reversed</span>(candidate_tiers):&#57344;&#57345;&#57345;
                        <span style="color: #859900;">if</span> other_replicas[t] == 0:&#57344;&#57345;&#57345;
                            tier = t&#57344;&#57345;&#57345;
                            <span style="color: #859900;">break</span>&#57344;&#57345;&#57345;
                <span style="color: #859900;">else</span>:&#57344;&#57345;&#57345;
                    min_count = <span style="color: #859900;">min</span>(other_replicas[t]&#57344;&#57345;&#57345;
                                    <span style="color: #859900;">for</span> t <span style="color: #859900;">in</span> candidate_tiers)&#57344;&#57345;&#57345;
                    tier = (t <span style="color: #859900;">for</span> t <span style="color: #859900;">in</span> <span style="color: #859900;">reversed</span>(candidate_tiers)&#57344;&#57345;&#57345;
                            <span style="color: #859900;">if</span> other_replicas[t] == min_count).<span style="color: #859900;">next</span>()&#57344;&#57345;&#57345;
                depth += 1&#57344;&#57345;&#57345;
            dev = tier2devs[tier][-1]&#57344;&#57345;&#57345;
            dev[<span style="color: #2aa198;">'parts_wanted'</span>] -= 1&#57344;&#57345;&#57345;
            dev[<span style="color: #2aa198;">'parts'</span>] += 1&#57344;&#57345;&#57345;
            old_sort_key = dev[<span style="color: #2aa198;">'sort_key'</span>]&#57344;&#57345;&#57345;
            <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#37325;&#26032;&#26681;&#25454;&#26032;&#30340;parts_wanted&#35745;&#31639;sort key</span>&#57344;&#57345;&#57345;
            new_sort_key = dev[<span style="color: #2aa198;">'sort_key'</span>] = <span style="color: #859900;">self</span>._sort_key_for(dev)&#57344;&#57345;&#57345;
            <span style="color: #859900;">for</span> tier <span style="color: #859900;">in</span> tiers_for_dev(dev):&#57344;&#57345;&#57345;
                other_replicas[tier] += 1&#57344;&#57345;&#57345;
                unique_tiers_by_tier_len[<span style="color: #859900;">len</span>(tier)].add(tier)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
                index = bisect.bisect_left(tier2sort_key[tier],&#57344;&#57345;&#57345;
                                           old_sort_key)&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#24377;&#20986;&#35813;dev</span>&#57344;&#57345;&#57345;
                tier2devs[tier].pop(index)&#57344;&#57345;&#57345;
                tier2sort_key[tier].pop(index)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
                new_index = bisect.bisect_left(tier2sort_key[tier],&#57344;&#57345;&#57345;
                                               new_sort_key)&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#29992;&#26032;&#30340;sort key&#25554;&#20837;&#21040;tier2devs&#20013;</span>&#57344;&#57345;&#57345;
                tier2devs[tier].insert(new_index, dev)&#57344;&#57345;&#57345;
                tier2sort_key[tier].insert(new_index, new_sort_key)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21516;&#26679;&#23545;tier2childre&#36827;&#34892;&#25805;&#20316;</span>&#57344;&#57345;&#57345;
                <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">Now jiggle tier2children values to keep them sorted</span>&#57344;&#57345;&#57345;
                new_last_sort_key = tier2sort_key[tier][-1]&#57344;&#57345;&#57345;
                parent_tier = tier[0:-1]&#57344;&#57345;&#57345;
                index = bisect.bisect_left(&#57344;&#57345;&#57345;
                    tier2children_sort_key[parent_tier],&#57344;&#57345;&#57345;
                    old_sort_key)&#57344;&#57345;&#57345;
                popped = tier2children[parent_tier].pop(index)&#57344;&#57345;&#57345;
                tier2children_sort_key[parent_tier].pop(index)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
                new_index = bisect.bisect_left(&#57344;&#57345;&#57345;
                    tier2children_sort_key[parent_tier],&#57344;&#57345;&#57345;
                    new_last_sort_key)&#57344;&#57345;&#57345;
                tier2children[parent_tier].insert(new_index, popped)&#57344;&#57345;&#57345;
                tier2children_sort_key[parent_tier].insert(&#57344;&#57345;&#57345;
                    new_index, new_last_sort_key)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
            <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#24314;&#31435;part&#21644;dev&#26144;&#23556;</span>&#57344;&#57345;&#57345;
            <span style="color: #859900;">self</span>._replica2part2dev[replica][part] = dev[<span style="color: #2aa198;">'id'</span>]&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
    <span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">Just to save memory and keep from accidental reuse.</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">for</span> dev <span style="color: #859900;">in</span> <span style="color: #859900;">self</span>._iter_devs():&#57344;&#57345;&#57345;
        <span style="color: #859900;">del</span> dev[<span style="color: #2aa198;">'sort_key'</span>]&#57344;&#57345;&#57345;
</pre>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">经典文章</h2>
<div class="outline-text-2" id="text-2">

<ul>
<li><a href="http://greg.brim.net/page/building_a_consistent_hashing_ring.html">Building a Consistent Hashing Ring</a>
</li>
</ul>


</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">nova develop environment</h2>
<div class="outline-text-2" id="text-3">

<ol>
<li>install package
   sudo apt-get install python-dev libssl-dev python-pip git-core libxml2-dev
   libxslt-dev libmysqld-dev
</li>
<li>get source code
   git clone <a href="https://github.com/openstack/nova.git">https://github.com/openstack/nova.git</a> nova-dev
</li>
<li>configure virtualenv<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>
   easy<sub>install</sub> Virtualenv
   cd nova-dev
   python tools/install<sub>env</sub>.py
   source .venv/bin/activate
</li>
<li>run unit test
   export PYTHONPATH=$PYTHONPATH:/home/tacy/workspace/nova-dev
   ./run<sub>tests</sub>.sh
</li>
</ol>


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> <a href="http://pypi.python.org/pypi/virtualenv">using virtualenv to create isolated python environments</a>
</p></div>
</div>

</div>
</div>
