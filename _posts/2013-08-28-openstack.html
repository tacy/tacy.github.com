---
layout: post
title: "openstack notes"
description: "Openstack的一些基本信息，自己的了解，认为好的一些资源收集，记录下来。"
categories: [tech]
tags: [openstack]
---

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Swift ring builder</a>
<ul>
<li><a href="#sec-1-1">1.1 add device</a></li>
<li><a href="#sec-1-2">1.2 rebalance</a></li>
</ul>
</li>
<li><a href="#sec-2">2 经典文章</a></li>
<li><a href="#sec-3">3 nova develop environment</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Swift ring builder</h2>
<div class="outline-text-2" id="text-1">

<p>  读了一下ringbuilder代码，简单记录一下，免的忘了。
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">add device</h3>
<div class="outline-text-3" id="text-1-1">

<p>   添加device的时候可以指定每个device的meta信息和replication ip，Swift会给每
   个device一个id，这个id会一直递增，也就是说新增加的device的id总是比device的id
   大，不会重用id
</p>


<pre class="example">if 'id' not in dev:
    dev['id'] = 0
    if self.devs:
        dev['id'] = max(d['id'] for d in self.devs if d) + 1
if dev['id'] &lt; len(self.devs) and self.devs[dev['id']] is not None:
    raise exceptions.DuplicateDeviceError(
        'Duplicate device id: %d' % dev['id'])
# Add holes to self.devs to ensure self.devs[dev['id']] will be the dev
while dev['id'] &gt;= len(self.devs):
    self.devs.append(None)
</pre>


<p>
   weight和Part之间的关系计算很简单
</p>


<pre class="example">return self.parts * self.replicas / \
    sum(d['weight'] for d in self._iter_devs())
</pre>


<p>
   在添加device的时候，会重新计算device所期望的Part（原有device需要减去已分配），这个
   值很关键，后面part和device的映射会根据这个值确定分配优先级（parts<sub>wanted大优先级高）</sub>
</p>


<pre class="example">for dev in self._iter_devs():
    if not dev['weight']:
        # With no weight, that means we wish to "drain" the device. So
        # we set the parts_wanted to a really large negative number to
        # indicate its strong desire to give up everything it has.
        dev['parts_wanted'] = -self.parts * self.replicas
    else:
        dev['parts_wanted'] = \
            int(weight_of_one_part * dev['weight']) - dev['parts']
</pre>


<p>
   添加device并不会导致数据迁移，必须显示调用rebalance才会执行平衡操作。
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">rebalance</h3>
<div class="outline-text-3" id="text-1-2">

<p>   relalance入口
</p>


<pre class="src src-python"><span style="color: #859900;">def</span> <span style="color: #268bd2;">rebalance</span>(<span style="color: #859900;">self</span>, seed=<span style="color: #2aa198;">None</span>):
    <span style="color: #2aa198;">"""</span>
<span style="color: #2aa198;">    Rebalance the ring.</span>

<span style="color: #2aa198;">    This is the main work function of the builder, as it will assign and</span>
<span style="color: #2aa198;">    reassign partitions to devices in the ring based on weights, distinct</span>
<span style="color: #2aa198;">    zones, recent reassignments, etc.</span>

<span style="color: #2aa198;">    The process doesn't always perfectly assign partitions (that'd take a</span>
<span style="color: #2aa198;">    lot more analysis and therefore a lot more time -- I had code that did</span>
<span style="color: #2aa198;">    that before). Because of this, it keeps rebalancing until the device</span>
<span style="color: #2aa198;">    skew (number of partitions a device wants compared to what it has) gets</span>
<span style="color: #2aa198;">    below 1% or doesn't change by more than 1% (only happens with ring that</span>
<span style="color: #2aa198;">    can't be balanced no matter what -- like with 3 zones of differing</span>
<span style="color: #2aa198;">    weights with replicas set to 3).</span>

<span style="color: #2aa198;">    :returns: (number_of_partitions_altered, resulting_balance)</span>
<span style="color: #2aa198;">    """</span>

    <span style="color: #859900;">if</span> seed:
        random.seed(seed)

    <span style="color: #859900;">self</span>._ring = <span style="color: #2aa198;">None</span>
    <span style="color: #859900;">if</span> <span style="color: #859900;">self</span>._last_part_moves_epoch <span style="color: #859900;">is</span> <span style="color: #2aa198;">None</span>:    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#22914;&#26524;&#20026;&#31354;&#65292;&#34920;&#31034;&#31532;&#19968;&#27425;&#20570;balance</span>
        <span style="color: #859900;">self</span>._initial_balance()                <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#36825;&#37324;&#30340;&#25805;&#20316;&#21644;&#37325;&#20570;balance&#24046;&#19981;&#22810;</span>
        <span style="color: #859900;">self</span>.devs_changed = <span style="color: #2aa198;">False</span>
        <span style="color: #859900;">return</span> <span style="color: #859900;">self</span>.parts, <span style="color: #859900;">self</span>.get_balance()
    <span style="color: #268bd2;">retval</span> = 0
    <span style="color: #859900;">self</span>._update_last_part_moves()
    <span style="color: #268bd2;">last_balance</span> = 0
    <span style="color: #268bd2;">new_parts</span>, <span style="color: #268bd2;">removed_part_count</span> = <span style="color: #859900;">self</span>._adjust_replica2part2dev_size()  <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#25910;&#38598;&#21738;&#20123;part&#38656;&#35201;&#20998;&#37197;dev</span>
    <span style="color: #268bd2;">retval</span> += removed_part_count
    <span style="color: #859900;">self</span>._reassign_parts(new_parts)            <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#25191;&#34892;&#20998;&#37197;&#25805;&#20316;</span>
    <span style="color: #268bd2;">retval</span> += <span style="color: #859900;">len</span>(new_parts)
    <span style="color: #859900;">while</span> <span style="color: #2aa198;">True</span>:
        <span style="color: #268bd2;">reassign_parts</span> = <span style="color: #859900;">self</span>._gather_reassign_parts()    <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#32479;&#35745;&#31227;&#38500;&#30340;device&#25345;&#26377;&#30340;part</span>
        <span style="color: #859900;">self</span>._reassign_parts(reassign_parts)              <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#21644;&#36229;&#36733;&#30340;device&#65292;&#25191;&#34892;&#20998;&#37197;&#25805;&#20316;</span>
        <span style="color: #268bd2;">retval</span> += <span style="color: #859900;">len</span>(reassign_parts)                     <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">&#37325;&#22797;&#25191;&#34892;balance&#65292;&#30452;&#21040;&#24179;&#34913;</span>
        <span style="color: #859900;">while</span> <span style="color: #859900;">self</span>._remove_devs:
            <span style="color: #859900;">self</span>.devs[<span style="color: #859900;">self</span>._remove_devs.pop()[<span style="color: #2aa198;">'id'</span>]] = <span style="color: #2aa198;">None</span>
        <span style="color: #268bd2;">balance</span> = <span style="color: #859900;">self</span>.get_balance()
        <span style="color: #859900;">if</span> balance &lt; 1 <span style="color: #859900;">or</span> <span style="color: #859900;">abs</span>(last_balance - balance) &lt; 1 <span style="color: #859900;">or</span> \
                retval == <span style="color: #859900;">self</span>.parts:
            <span style="color: #859900;">break</span>
        last_balance = balance
    <span style="color: #859900;">self</span>.devs_changed = <span style="color: #2aa198;">False</span>
    <span style="color: #859900;">self</span>.version += 1
    <span style="color: #859900;">return</span> retval, balance
</pre>


<p>
   <sub>reassign</sub><sub>parts</sub>()完成核心的part到dev的映射
</p>


<pre class="example">def _reassign_parts(self, reassign_parts):
    """
    For an existing ring data set, partitions are reassigned similarly to
    the initial assignment. The devices are ordered by how many partitions
    they still want and kept in that order throughout the process. The
    gathered partitions are iterated through, assigning them to devices
    according to the "most wanted" while keeping the replicas as "far
    apart" as possible. Two different regions are considered the
    farthest-apart things, followed by zones, then different ip/port pairs
    within a zone; the least-far-apart things are different devices with
    the same ip/port pair in the same zone.

    If you want more replicas than devices, you won't get all your
    replicas.

    :param reassign_parts: An iterable of (part, replicas_to_replace)
                           pairs. replicas_to_replace is an iterable of the
                           replica (an int) to replace for that partition.
                           replicas_to_replace may be shared for multiple
                           partitions, so be sure you do not modify it.
    """
    for dev in self._iter_devs():
        dev['sort_key'] = self._sort_key_for(dev)      #生成按照parts_wanted排序的key

    available_devs = \
        sorted((d for d in self._iter_devs() if d['weight']),
               key=lambda x: x['sort_key'])

    tier2devs = defaultdict(list)
    tier2sort_key = defaultdict(list)
    max_tier_depth = 0
    for dev in available_devs:
        for tier in tiers_for_dev(dev):
            tier2devs[tier].append(dev)  # &lt;-- starts out sorted!   #生成tier和dev的关系结构，包括
            tier2sort_key[tier].append(dev['sort_key'])             #{(region)[dev]}，{(region,zone):[dev]}
            if len(tier) &gt; max_tier_depth:                          #{(region,zone,machine):[dev]}
                max_tier_depth = len(tier)                          #{(region,zone,machine,id):[dev]}

    tier2children_sets = build_tier_tree(available_devs)           #生成tiger和children关系，{():[region]}
    tier2children = defaultdict(list)                              #{(region):[(region,zone)]}
    tier2children_sort_key = {}                                    #{(region,zone):[(region,zone,machine)]
    tiers_list = [()]                                              #{(region,zone,machine):[region,zone,machine,devid]}
    depth = 1
    while depth &lt;= max_tier_depth:
        new_tiers_list = []
        for tier in tiers_list:
            child_tiers = list(tier2children_sets[tier])
            child_tiers.sort(key=lambda t: tier2sort_key[t][-1])
            tier2children[tier] = child_tiers
            tier2children_sort_key[tier] = map(
                lambda t: tier2sort_key[t][-1], child_tiers)
            new_tiers_list.extend(child_tiers)
        tiers_list = new_tiers_list
        depth += 1

    for part, replace_replicas in reassign_parts:                       #遍历tier2children关系，找最需要分配的dev
        # Gather up what other tiers (regions, zones, ip/ports, and
        # devices) the replicas not-to-be-moved are in for this part.
        other_replicas = defaultdict(int)
        unique_tiers_by_tier_len = defaultdict(set)
        for replica in self._replicas_for_part(part):
            if replica not in replace_replicas:
                dev = self.devs[self._replica2part2dev[replica][part]]
                for tier in tiers_for_dev(dev):
                    other_replicas[tier] += 1
                    unique_tiers_by_tier_len[len(tier)].add(tier)

        for replica in replace_replicas:
            tier = ()
            depth = 1
            while depth &lt;= max_tier_depth:
                # Order the tiers by how many replicas of this
                # partition they already have. Then, of the ones
                # with the smallest number of replicas, pick the
                # tier with the hungriest drive and then continue
                # searching in that subtree.
                #
                # There are other strategies we could use here,
                # such as hungriest-tier (i.e. biggest
                # sum-of-parts-wanted) or picking one at random.
                # However, hungriest-drive is what was used here
                # before, and it worked pretty well in practice.
                #
                # Note that this allocator will balance things as
                # evenly as possible at each level of the device
                # layout. If your layout is extremely unbalanced,
                # this may produce poor results.
                #
                # This used to be a cute, recursive function, but it's been
                # unrolled for performance.
                candidate_tiers = tier2children[tier]
                candidates_with_replicas = \
                    unique_tiers_by_tier_len[len(tier) + 1]
                if len(candidate_tiers) &gt; len(candidates_with_replicas):
                    # There exists at least one tier with 0 other replicas,
                    # so work backward among the candidates, accepting the
                    # first which isn't in other_replicas.
                    #
                    # This optimization is to avoid calling the min()
                    # below, which is expensive if you've got thousands of
                    # drives.
                    for t in reversed(candidate_tiers):
                        if other_replicas[t] == 0:
                            tier = t
                            break
                else:
                    min_count = min(other_replicas[t]
                                    for t in candidate_tiers)
                    tier = (t for t in reversed(candidate_tiers)
                            if other_replicas[t] == min_count).next()
                depth += 1
            dev = tier2devs[tier][-1]
            dev['parts_wanted'] -= 1
            dev['parts'] += 1
            old_sort_key = dev['sort_key']
            new_sort_key = dev['sort_key'] = self._sort_key_for(dev)    #重新根据新的parts_wanted计算sort key
            for tier in tiers_for_dev(dev):
                other_replicas[tier] += 1
                unique_tiers_by_tier_len[len(tier)].add(tier)

                index = bisect.bisect_left(tier2sort_key[tier],
                                           old_sort_key)
                tier2devs[tier].pop(index)                                #弹出该dev
                tier2sort_key[tier].pop(index)

                new_index = bisect.bisect_left(tier2sort_key[tier],
                                               new_sort_key)
                tier2devs[tier].insert(new_index, dev)                    #用新的sort key插入到tier2devs中
                tier2sort_key[tier].insert(new_index, new_sort_key)

                # Now jiggle tier2children values to keep them sorted     #同样对tier2childre进行操作
                new_last_sort_key = tier2sort_key[tier][-1]
                parent_tier = tier[0:-1]
                index = bisect.bisect_left(
                    tier2children_sort_key[parent_tier],
                    old_sort_key)
                popped = tier2children[parent_tier].pop(index)
                tier2children_sort_key[parent_tier].pop(index)

                new_index = bisect.bisect_left(
                    tier2children_sort_key[parent_tier],
                    new_last_sort_key)
                tier2children[parent_tier].insert(new_index, popped)
                tier2children_sort_key[parent_tier].insert(
                    new_index, new_last_sort_key)

            self._replica2part2dev[replica][part] = dev['id']               #建立part和dev映射

    # Just to save memory and keep from accidental reuse.
    for dev in self._iter_devs():
        del dev['sort_key']

</pre>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">经典文章</h2>
<div class="outline-text-2" id="text-2">

<ul>
<li><a href="http://greg.brim.net/page/building_a_consistent_hashing_ring.html">Building a Consistent Hashing Ring</a>
</li>
</ul>


</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">nova develop environment</h2>
<div class="outline-text-2" id="text-3">

<ol>
<li>install package
   sudo apt-get install python-dev libssl-dev python-pip git-core libxml2-dev libxslt-dev libmysqld-dev
</li>
<li>get source code
   git clone <a href="https://github.com/openstack/nova.git">https://github.com/openstack/nova.git</a> nova-dev
</li>
<li>configure virtualenv<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>
   easy<sub>install</sub> Virtualenv
   cd nova-dev
   python tools/install<sub>env</sub>.py
   source .venv/bin/activate
</li>
<li>run unit test
   export PYTHONPATH=$PYTHONPATH:/home/tacy/workspace/nova-dev
   ./run<sub>tests</sub>.sh
</li>
</ol>


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> virtualenv is a tool to create isolated python environments. using "virtualenv you-env-name" to create a env, "source bin/activate" activate env. reference link: <a href="http://pypi.python.org/pypi/virtualenv">http://pypi.python.org/pypi/virtualenv</a>
</p></div>
</div>

</div>
</div>
